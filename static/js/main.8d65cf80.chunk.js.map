{"version":3,"sources":["timestamp.tsx","util.ts","NoteLine.ts","DriveSyncHandler.ts","Note.ts","LocalStore.ts","NoteContentHandler.ts","noterow.tsx","notetitle.tsx","menu.tsx","App.tsx","serviceWorker.js","index.js"],"names":["Timestamp","props","interval","state","timestamp","initialTimestamp","className","this","toLocaleString","hour","minute","second","hour12","setState","Date","shouldTick","setupTimer","prevProps","prevState","window","clearInterval","setInterval","tick","React","Component","computeIndentString","units","Array","INDENT_LENGTH","fill","join","DriveSignInState","NoteLine","editTimestamp","note","indentedUnits","content","creationTimestamp","updateLastEditTime","setEditTimestamp","i","trim","length","id","getTime","rawNoteLine","noteLine","setContent","setCreationTimestamp","Note","noteLines","Map","noteLineIdsOrdered","title","creationTime","finished","driveId","makeDefaultTitle","toLocaleDateString","set","push","from","values","get","Math","min","keys","output","forEach","line","convertToText","lineIndex","indexOf","max","delete","idIndex","splice","console","error","orderedNoteLineIds","map","noteLineId","undefined","Error","serialize","rawNote","setTitle","setFinished","setDriveId","parsedNoteLines","deserialize","noteLineMap","setNoteLines","getNoteStorageId","localStorage","JSON","stringify","lastEditKey","parse","debug","LocalStore","saveNote","getLastEditedNote","NoteRow","timestampElement","createRef","entryboxElement","getLine","rowId","getIndentedUnits","entryboxContent","computeEntryboxContent","getContent","editedSinceLastFocus","focused","ref","getLastEditTimestamp","computeTimestampShouldTick","onFocus","handleEntryboxFocus","bind","onKeyDown","handleKeyDown","onChange","handleChange","value","readOnly","rows","getFinished","isEmpty","rawContent","oldProps","oldState","setIndentedUnits","NoteContentHandler","updateNote","current","focus","e","target","keyDownHandler","key","preventDefault","shiftKey","focusHandler","currentRawLength","textLength","setSelectionRange","NoteTitle","divRef","editing","onClick","handleClick","contentEditable","onBlur","handleBlur","suppressContentEditableWarning","titleChangeHandler","textContent","blur","DISCOVERY_DOCS","DOC_MIME","signedInEventHandlers","gapi","load","initClient","client","init","apiKey","clientId","discoveryDocs","scope","then","auth2","getAuthInstance","isSignedIn","listen","handleIsSignedInState","log","signInState","SIGNED_IN","SIGNED_OUT","handler","getDriveId","getParentFolderId","parentId","drive","files","create","name","getTitle","mimeType","parents","response","status","result","uploadContent","xhr","XMLHttpRequest","open","setRequestHeader","getToken","access_token","Promise","resolve","reject","onload","send","Menu","driveSignInState","LOADING","DriveSyncHandler","addSignInStateHandler","toggleFinishString","noteFinished","driveMenuItems","Dropdown","Item","signOutHandler","signInHandler","DropdownButton","alignRight","newNoteHandler","finishToggleHandler","Divider","ViewInDocsLink","noteDriveId","href","App","wrapperElement","editedSinceLastDriveSync","syncTimer","firstNoteLineId","createNewNote","getFirstNoteLineId","focusedNoteRowId","addLine","a","clearTimeout","noteRows","getLines","noteRow","handleNoteRowKeyDown","noteRowFocusHandler","handleTitleChange","handleToggleFinished","signIn","signOut","newTitle","newNote","focusedRow","nextFocusedRowId","getPreviousRowId","deleteRow","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.8d65cf80.chunk.js","sourcesContent":["import React from \"react\";\n\ninterface TimestampState {\n    timestamp: Date;\n}\n\ninterface TimestampProps {\n    shouldTick: boolean;\n    initialTimestamp: Date;\n}\n\nexport class Timestamp extends React.Component<TimestampProps, TimestampState> {\n    interval: number;\n\n    constructor(props: TimestampProps) {\n        super(props);\n        this.state = { timestamp: this.props.initialTimestamp };\n        this.interval = -1;\n    }\n\n    render() {\n        return (\n            <span className=\"timestamp\">\n                {this.state.timestamp.toLocaleString(\"en-us\", {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\",\n                    second: \"2-digit\",\n                    hour12: false\n                })}\n            </span>\n        );\n    }\n\n    tick() {\n        this.setState(state => ({ timestamp: new Date() }));\n    }\n\n    componentDidMount() {\n        if (this.props.shouldTick) {\n            this.setupTimer();\n        }\n    }\n\n    componentDidUpdate(prevProps: TimestampProps, prevState: TimestampState) {\n        if (prevProps.shouldTick !== this.props.shouldTick) {\n            if (this.props.shouldTick) {\n                this.setupTimer();\n            } else {\n                window.clearInterval(this.interval);\n            }\n        }\n    }\n\n    setupTimer() {\n        this.interval = window.setInterval(() => this.tick(), 500);\n    }\n\n    componentWillUnmount() {\n        window.clearInterval(this.interval);\n    }\n}\n","import { INDENT_LENGTH } from './NoteLine'\r\n\r\nexport function computeIndentString(units: number): string {\r\n    /*eslint no-array-constructor: \"error\"*/\r\n    return new Array(units * INDENT_LENGTH)\r\n        .fill(\" \")\r\n        .join(\"\");\r\n}\r\n\r\nexport function removeIndent(str: string): string {\r\n    if (str.slice(0, INDENT_LENGTH - 1).trim().length === 0) {\r\n        return str.slice(INDENT_LENGTH);\r\n    }\r\n    \r\n    return str;\r\n}","import { Note } from \"./Note\";\nimport { computeIndentString } from \"./util\";\n\nexport const INDENT_LENGTH = 4;\n\nexport interface RawNoteLine {\n  content: string,\n  indentedUnits: number,\n  id: number,\n  editTimestamp: number;\n}\n\nexport class NoteLine {\n  private content: string = \"\";\n  private indentedUnits: number = 0;\n  private creationTimestamp: Date;\n\n  constructor(private editTimestamp: Date, private note: Note, indentedUnits?: number) {\n    this.creationTimestamp = new Date();\n    this.indentedUnits = indentedUnits || 0;\n  }\n\n  private setCreationTimestamp(timestamp: Date) {\n    this.creationTimestamp = timestamp;\n  }\n\n  get id(): number {\n    return this.creationTimestamp.getTime();\n  }\n\n  getContent(): string {\n    return this.content;\n  }\n\n  setContent(content: string, updateLastEditTime?: boolean) {\n    this.content = content;\n\n    if (updateLastEditTime) {\n      this.setEditTimestamp(new Date());\n    }\n  }\n\n  getLastEditTimestamp(): Date {\n    return this.editTimestamp;\n  }\n\n  setEditTimestamp(timestamp: Date) {\n    this.editTimestamp = timestamp;\n  }\n\n  getIndentedUnits(): number {\n    return this.indentedUnits;\n  }\n\n  setIndentedUnits(i: number) {\n    this.indentedUnits = i;\n  }\n\n  isEmpty(): boolean {\n    return (this.content.trim().length === 0);\n  }\n\n  convertToText(): string {\n    return this.editTimestamp.toLocaleString(\"en-us\", {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\",\n                    second: \"2-digit\",\n                    hour12: false\n                })\n                + \" - \"\n                + computeIndentString(this.indentedUnits)\n                + this.content;\n  }\n\n  serialize(): RawNoteLine {\n    return {\n      id: this.id,\n      content: this.content,\n      indentedUnits: this.indentedUnits,\n      editTimestamp: this.editTimestamp.getTime()\n    }\n  }\n\n  static deserialize(note: Note, rawNoteLine: RawNoteLine): NoteLine {\n    let noteLine = new NoteLine(new Date(rawNoteLine.editTimestamp), note, rawNoteLine.indentedUnits);\n\n    noteLine.setContent(rawNoteLine.content)\n    noteLine.setCreationTimestamp(new Date(rawNoteLine.id));\n    return noteLine;\n  }\n}\n","import { Note } from \"./Note\";\r\n\r\ndeclare var gapi: any;\r\n\r\nconst API_KEY = \"AIzaSyBEH9v-TByqUFESw8vjl2YEDgAKoWm7n_8\";\r\nconst CLIENT_ID = \"370774814885-7kseam56ntmpklgnr9p00f8gh968cmtb.apps.googleusercontent.com\";\r\n// Array of API discovery doc URLs for APIs used by the quickstart\r\nconst DISCOVERY_DOCS = [\"https://www.googleapis.com/discovery/v1/apis/drive/v3/rest\"];\r\n\r\n// Authorization scopes required by the API; multiple scopes can be\r\n// included, separated by spaces.\r\nconst SCOPES = 'https://www.googleapis.com/auth/drive.file';\r\n\r\nconst DIRECTORY_MIME = \"application/vnd.google-apps.folder\";\r\nconst DOC_MIME = \"application/vnd.google-apps.document\";\r\n\r\nconst PARENT_NAME = \"Synced Interview Notes\";\r\nconst PARENT_ID_STORAGE_KEY = \"parent-drive-id\";\r\n\r\nexport enum DriveSignInState {\r\n    LOADING,\r\n    SIGNED_OUT,\r\n    SIGNED_IN\r\n}\r\n\r\ntype SignedInEventHandler = (isSignedIn: DriveSignInState) => void;\r\n\r\nclass DriveSyncHandler {\r\n    private signedInEventHandlers: Array<SignedInEventHandler> = [];\r\n\r\n    async init(): Promise<void> {\r\n        return gapi.load('client:auth2', this.initClient.bind(this));\r\n    }\r\n\r\n    initClient() {\r\n        gapi.client.init({\r\n            apiKey: API_KEY,\r\n            clientId: CLIENT_ID,\r\n            discoveryDocs: DISCOVERY_DOCS,\r\n            scope: SCOPES\r\n        }).then(() => {\r\n            // Listen for sign-in state changes.\r\n            gapi.auth2.getAuthInstance().isSignedIn.listen(this.handleIsSignedInState.bind(this));\r\n\r\n            this.handleIsSignedInState(gapi.auth2.getAuthInstance().isSignedIn.get());\r\n        })\r\n    }\r\n\r\n    handleIsSignedInState(isSignedIn: boolean) {\r\n        console.log('user is now', isSignedIn);\r\n\r\n        let signInState = (isSignedIn) ? DriveSignInState.SIGNED_IN : DriveSignInState.SIGNED_OUT;\r\n        for (let handler of this.signedInEventHandlers) {\r\n            handler(signInState);\r\n        }\r\n    }\r\n\r\n    addSignInStateHandler(handler: SignedInEventHandler) {\r\n        this.signedInEventHandlers.push(handler);\r\n    }\r\n\r\n    isUserSignedIn(): boolean {\r\n        return gapi.auth2.getAuthInstance().isSignedIn.get()\r\n    }\r\n\r\n    async saveNote(note: Note): Promise<string> {\r\n        console.log(\"Saving note to drive: \", note);\r\n\r\n        let id;\r\n        if (note.getDriveId().length === 0) {\r\n            let parentId = await this.getParentFolderId();\r\n\r\n            let response = await gapi.client.drive.files.create({\r\n                name: note.getTitle(),\r\n                mimeType: DOC_MIME,\r\n                parents: [parentId],\r\n            })\r\n\r\n            console.log(\"Got create response: \", response);\r\n\r\n            if (response.status !== 200) {\r\n                throw new Error(\"Got bad create response code\");\r\n            }\r\n            id = response.result.id;\r\n        } else {\r\n            id = note.getDriveId();\r\n        }\r\n\r\n        await this.uploadContent(note.getDriveId(), note.convertToText());\r\n        return id;\r\n    }\r\n\r\n    async getParentFolderId(): Promise<string> {\r\n        let id = window.localStorage[PARENT_ID_STORAGE_KEY];\r\n        if (id === undefined) {\r\n            let response = await gapi.client.drive.files.create({\r\n                mimeType: DIRECTORY_MIME,\r\n                name: PARENT_NAME\r\n            })\r\n\r\n            console.log(\"got create response: \", response);\r\n            if (response.status !== 200) {\r\n                throw new Error(\"Got bad create response code\");\r\n            }\r\n\r\n            id = response.result.id;\r\n            window.localStorage[PARENT_ID_STORAGE_KEY] = id;\r\n        } else {\r\n            console.log(\"Reusing drive id: \", id);\r\n        }\r\n        return id;\r\n    }\r\n\r\n    async uploadContent(driveId: string, content: string): Promise<string> {\r\n        let xhr = new XMLHttpRequest();\r\n        xhr.open(\"PATCH\", \"https://www.googleapis.com/upload/drive/v3/files/\" + driveId + \"?uploadType=media\");\r\n        xhr.setRequestHeader(\"Authorization\", \"Bearer \" + gapi.client.getToken().access_token);\r\n        xhr.setRequestHeader(\"Content-Type\", DOC_MIME);\r\n\r\n        return new Promise<string>((resolve, reject) => {\r\n            xhr.onload = () => resolve();\r\n            xhr.send(content);\r\n        });\r\n    }\r\n}\r\n\r\n\r\nexport default new DriveSyncHandler();","import { RawNoteLine, NoteLine } from \"./NoteLine\";\n\nexport interface RawNote {\n  id: number,\n  title: string,\n  noteLines: Array<RawNoteLine>\n  finished: boolean;\n  driveId: string;\n}\n\nexport class Note {\n  noteLines: Map<number, NoteLine> = new Map<number, NoteLine>();\n  // Since new lines can be inserted anywhere in the note, we need\n  // a separate array keeping track of the visual ordering of the rows\n  // in the note relative to each other.\n  noteLineIdsOrdered: Array<number> = [];\n  private title: string;\n  private creationTime: Date;\n  private finished: boolean = false;\n  private driveId: string = \"\";\n\n  constructor() {\n    this.creationTime = new Date();\n\n    this.title = this.makeDefaultTitle();\n  }\n\n  makeDefaultTitle(): string {\n    return \"Interview on \"+ this.creationTime.toLocaleDateString();\n  }\n\n  get id(): number {\n    return this.creationTime.getTime();\n  }\n\n  addLine(indentedUnits?: number): NoteLine {\n    let noteLine = new NoteLine(new Date(), this, indentedUnits);\n    this.noteLines.set(noteLine.id, noteLine);\n    this.noteLineIdsOrdered.push(noteLine.id);\n\n    return noteLine;\n  }\n\n  getLines(): Array<NoteLine> {\n    return Array.from(this.noteLines.values());\n  }\n\n  getLine(id: number): NoteLine | undefined {\n    return this.noteLines.get(id);\n  }\n\n  getFirstNoteLineId(): number {\n    return Math.min(...Array.from(this.noteLines.keys()));\n  }\n\n  getTitle(): string {\n      return this.title;\n  }\n\n  setTitle(title: string) {\n    this.title = title;\n  }\n\n  getFinished(): boolean {\n    return this.finished;\n  }\n\n  setFinished(finished: boolean) {\n    this.finished = finished;\n  }\n\n  getDriveId(): string {\n    return this.driveId || \"\";\n  }\n\n  setDriveId(driveId: string) {\n    this.driveId = driveId;\n  }\n\n  convertToText(): string {\n\n    let output = \"\";\n    this.noteLines.forEach(line => {\n      output += line.convertToText() + \"\\n\";\n    });\n\n    return output;\n  }\n\n  getPreviousRowId(id: number): number | null {\n    let lineIndex = this.noteLineIdsOrdered.indexOf(id);\n\n    if (lineIndex === -1) {\n      return null;\n    }\n\n    return this.noteLineIdsOrdered[Math.max(0, lineIndex - 1)];\n  }\n\n  deleteRow(id: number) {\n    this.noteLines.delete(id);\n    let idIndex = this.noteLineIdsOrdered.indexOf(id);\n\n    if (idIndex !== -1) {\n      this.noteLineIdsOrdered.splice(idIndex);\n    } else {\n      console.error(\"Tried to delete non-existent row with ID: \", id, this);\n    }\n  }\n\n  private setNoteLines(orderedNoteLineIds: Array<number>, noteLines: Map<number, NoteLine>) {\n    this.noteLineIdsOrdered = orderedNoteLineIds;\n    this.noteLines = noteLines;\n  }\n\n  serialize(): RawNote {\n    return {\n      title: this.title,\n      id: this.id,\n      finished: this.finished,\n      driveId: this.driveId,\n      noteLines: this.noteLineIdsOrdered.map(noteLineId => {\n        let noteLine = this.noteLines.get(noteLineId);\n        \n        if (noteLine === undefined) {\n          console.error(\"Note: \", this);\n          throw new Error(\"Got undefined note line during serialization.\");\n        }\n\n        return noteLine.serialize();\n      })\n    }\n  }\n\n  static deserialize(rawNote: RawNote): Note {\n    let note = new Note();\n    note.setTitle(rawNote.title);\n    note.setFinished(rawNote.finished);\n    note.setDriveId(rawNote.driveId);\n\n    let parsedNoteLines = rawNote.noteLines.map(rawNoteLine => NoteLine.deserialize(note, rawNoteLine));\n    let noteLineMap = new Map<number, NoteLine>();\n    parsedNoteLines.forEach(noteLine => noteLineMap.set(noteLine.id, noteLine));\n    note.setNoteLines(rawNote.noteLines.map(rawNoteLine => rawNoteLine.id), noteLineMap);\n    return note;\n  }\n}\n","import { Note } from \"./Note\";\r\n\r\nconst LAST_EDIT_KEY = 'lastEditedNote';\r\nclass LocalStore {\r\n\r\n    saveNote(note: Note) {\r\n        let id = this.getNoteStorageId(note);\r\n        window.localStorage[id] = JSON.stringify(note.serialize());\r\n        window.localStorage[LAST_EDIT_KEY] = id;\r\n    }\r\n\r\n    getLastEditedNote(): Note | null {\r\n        let lastEditKey = window.localStorage[LAST_EDIT_KEY];\r\n        if (lastEditKey === undefined) {\r\n            return null;\r\n        }\r\n\r\n        let rawNote = window.localStorage[lastEditKey];\r\n\r\n        if (rawNote === undefined) {\r\n            console.error(\"Tried to fetch non-existent note: \", lastEditKey);\r\n            return null;\r\n        }\r\n\r\n        return Note.deserialize(JSON.parse(rawNote));\r\n    }\r\n\r\n    getNoteStorageId(note: Note): string {\r\n        return 'note-' + note.id;\r\n    }\r\n}\r\n\r\nexport default new LocalStore();","import { Note } from './Note';\r\nimport LocalStore from \"./LocalStore\";\r\n\r\nclass NoteContentHandler {\r\n    updateNote(note: Note) {\r\n        console.debug(\"Updating note: \", note);\r\n        LocalStore.saveNote(note);\r\n    }\r\n\r\n    getLastEditedNote(): Note | null {\r\n        return LocalStore.getLastEditedNote();\r\n    }\r\n}\r\n\r\nexport default new NoteContentHandler();","import React from \"react\";\nimport { Timestamp } from \"./timestamp\";\nimport { NoteLine } from \"./NoteLine\";\nimport { Note } from \"./Note\";\nimport NoteContentHandler from \"./NoteContentHandler\";\nimport { computeIndentString } from \"./util\";\n\ninterface NoteRowProps {\n    focusHandler: Function;\n    keyDownHandler: Function;\n    note: Note;\n    rowId: number;\n    focused: boolean;\n}\n\ninterface NoteRowState {\n    indentedUnits: number;\n    entryboxContent: string;\n    editedSinceLastFocus: boolean;\n}\n\nexport class NoteRow extends React.Component<NoteRowProps, NoteRowState> {\n    timestampElement = React.createRef<Timestamp>();\n    entryboxElement = React.createRef<HTMLTextAreaElement>();\n    noteLine: NoteLine;\n\n    constructor(props: NoteRowProps) {\n        super(props);\n\n        let noteLine = props.note.getLine(props.rowId);\n        if (noteLine === undefined) {\n            console.error(\"Note: \", props.note);\n            throw new Error(\"Got bad row id. Provided row id: \" + props.rowId);\n        }\n\n        this.noteLine = noteLine;\n\n        this.state = {\n            indentedUnits: this.noteLine.getIndentedUnits(),\n            entryboxContent: this.computeEntryboxContent(this.noteLine.getIndentedUnits(), this.noteLine.getContent()),\n            editedSinceLastFocus: false\n        };\n    }\n\n    render() {\n        return (\n            <div className={`noterow ${this.props.focused ? 'noterow-focused' : 'noterow-unfocused'}`}>\n                <Timestamp ref={this.timestampElement}\n                    initialTimestamp={this.noteLine.getLastEditTimestamp()}\n                    shouldTick={this.computeTimestampShouldTick()} />\n                <textarea ref={this.entryboxElement}\n                    onFocus={this.handleEntryboxFocus.bind(this)}\n                    onKeyDown={this.handleKeyDown.bind(this)}\n                    onChange={this.handleChange.bind(this)}\n                    value={this.state.entryboxContent}\n                    readOnly={!this.props.focused}\n                    rows={1}\n                    className=\"entrybox\"></textarea>\n            </div>\n        )\n    }\n\n    computeTimestampShouldTick() {\n        if (this.props.note.getFinished()) {\n            return false;\n        }\n\n        let isEmpty = (this.state.entryboxContent.trim().length === 0);\n        if (isEmpty && this.props.focused) {\n            return true;\n        }\n        \n        if (!isEmpty && this.state.editedSinceLastFocus) {\n            return true;\n        }\n\n        return false;\n    }\n\n    computeEntryboxContent(indentedUnits: number, rawContent: string) {\n        return computeIndentString(indentedUnits) + rawContent.trim();\n    }\n\n\n    componentDidUpdate(oldProps: NoteRowProps, oldState: NoteRowState) {\n        if (oldState.indentedUnits !== this.state.indentedUnits) {\n            this.setState(state => ({\n                entryboxContent: this.computeEntryboxContent(this.state.indentedUnits, this.state.entryboxContent)\n            }));\n            this.noteLine.setIndentedUnits(this.state.indentedUnits);\n        }\n\n        if (oldState.entryboxContent !== this.state.entryboxContent) {\n            this.noteLine.setContent(this.state.entryboxContent, true);\n            NoteContentHandler.updateNote(this.props.note);\n        }\n\n        if (oldProps.focused !== this.props.focused && !this.props.focused) {\n            this.setState({ editedSinceLastFocus: false })\n        }\n        if (this.entryboxElement.current !== null) {\n            if (this.props.focused) {\n                this.entryboxElement.current.focus();\n            }\n        }\n    }\n\n    componentDidMount() {\n        if (this.entryboxElement.current !== null) {\n            if (this.props.focused) {\n                this.entryboxElement.current.focus();\n            }\n        }\n    }\n\n    handleChange(e: React.ChangeEvent) {\n        this.setState({ entryboxContent: (e.target as HTMLTextAreaElement).value, editedSinceLastFocus: true });\n        NoteContentHandler.updateNote(this.props.note);\n    }\n\n    handleKeyDown(e: React.KeyboardEvent) {\n        if (!this.props.keyDownHandler(this.noteLine, e)) {\n            return;\n        }\n\n        if (e.key === \"Tab\") {\n            e.preventDefault();\n            if (e.shiftKey) {\n                this.setState(state => ({ indentedUnits: Math.max(state.indentedUnits - 1, 0) }));\n            } else {\n                this.setState(state => ({ indentedUnits: state.indentedUnits + 1 }));\n            }\n        }\n    }\n\n    handleEntryboxFocus(e: React.FocusEvent) {\n        this.props.focusHandler(this.noteLine);\n\n        if (this.state.entryboxContent.trim().length === 0 && this.entryboxElement.current != null) {\n            let currentRawLength = this.entryboxElement.current.textLength;\n            this.entryboxElement.current.setSelectionRange(currentRawLength, currentRawLength);\n        }\n    }\n}","import React from 'react';\n\ninterface NoteTitleProps {\n    title: string;\n    titleChangeHandler: (newTitle: string) => any;\n}\n\ninterface NoteTitleState {\n    editing: boolean;\n}\n\nexport class NoteTitle extends React.Component<NoteTitleProps, NoteTitleState> {\n    divRef = React.createRef<HTMLDivElement>();\n\n    constructor(props: NoteTitleProps) {\n        super(props);\n\n        this.state = { editing: false }\n    }\n\n    render() {\n        return (\n            <div className=\"note-title\"\n            ref={this.divRef}\n            onClick={this.handleClick.bind(this)}\n            contentEditable={true}\n            onKeyDown={this.handleKeyDown.bind(this)}\n            onBlur={this.handleBlur.bind(this)}\n            suppressContentEditableWarning={true}>\n                {this.props.title}\n            </div>\n        )\n    }\n\n    handleClick(e: React.MouseEvent) {\n        this.setState({ editing: true });\n    }\n\n    handleKeyDown(e: React.KeyboardEvent) {\n        if (e.key === 'Enter' && this.divRef.current !== null) {\n            e.preventDefault();\n            this.props.titleChangeHandler(this.divRef.current.textContent || \"\");\n            this.setState({ editing: false})\n            this.divRef.current.blur();\n        }\n    }\n\n    handleBlur(e: React.FocusEvent) {\n        if (this.divRef.current !== null) {\n            this.divRef.current.textContent = this.props.title;\n        }\n    }\n}","import React from 'react';\r\nimport Dropdown from 'react-bootstrap/Dropdown';\r\nimport DropdownButton from 'react-bootstrap/DropdownButton';\r\nimport {DriveSignInState} from './DriveSyncHandler';\r\nimport DriveSyncHandler from './DriveSyncHandler';\r\n\r\ninterface MenuProps {\r\n    newNoteHandler: () => void;\r\n    finishToggleHandler: () => void;\r\n    signInHandler: () => void;\r\n    signOutHandler: () => void;\r\n    noteFinished: boolean;\r\n}\r\n\r\ninterface MenuState {\r\n  open: boolean;\r\n  driveSignInState: DriveSignInState;\r\n}\r\n\r\nexport class Menu extends React.Component<MenuProps, MenuState> {\r\n    constructor(props: MenuProps) {\r\n        super(props);\r\n\r\n        this.state = { open: false, driveSignInState: DriveSignInState.LOADING}\r\n        DriveSyncHandler.addSignInStateHandler((isSignedIn: DriveSignInState) =>{\r\n            this.setState({ driveSignInState: isSignedIn})\r\n        })\r\n    }\r\n\r\n    render() {\r\n        let toggleFinishString = (this.props.noteFinished)\r\n                        ? \"Mark Note Unfinished\"\r\n                        : \"Mark Note Finished\";\r\n        \r\n        let driveMenuItems: Array<any> = [];\r\n\r\n        if (this.state.driveSignInState === DriveSignInState.SIGNED_IN) {\r\n            driveMenuItems = [\r\n                <Dropdown.Item key=\"signout\" onClick={(e: React.MouseEvent<any>) => this.props.signOutHandler()}>\r\n                    Sign out of Google Drive\r\n                </Dropdown.Item>\r\n            ]\r\n        } else if (this.state.driveSignInState === DriveSignInState.SIGNED_OUT) {\r\n            driveMenuItems = [\r\n                <Dropdown.Item key=\"signin\" onClick={(e: React.MouseEvent<any>) => this.props.signInHandler()}>\r\n                    Sign into Google Drive\r\n                </Dropdown.Item>\r\n            ];\r\n        }\r\n\r\n        \r\n        return (\r\n            <DropdownButton alignRight id=\"menu\" title=\"Menu\">\r\n                <Dropdown.Item onClick={(e: React.MouseEvent<any>) => this.props.newNoteHandler()}>New Note</Dropdown.Item>\r\n                <Dropdown.Item onClick={(e: React.MouseEvent<any>) => this.props.finishToggleHandler()}>\r\n                    {toggleFinishString}\r\n                </Dropdown.Item>\r\n                <Dropdown.Divider />\r\n                {driveMenuItems}\r\n            </DropdownButton>\r\n        )\r\n    }\r\n\r\n    handleMenuIconClick(e: React.MouseEvent) {\r\n    }\r\n\r\n    resetHandler(e: React.MouseEvent) {\r\n    }\r\n}","import React from 'react';\nimport './App.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport { NoteRow } from './noterow';\nimport { NoteLine } from './NoteLine';\nimport { NoteTitle } from './notetitle';\nimport { Note } from './Note';\nimport { Menu } from './menu';\nimport NoteContentHandler from './NoteContentHandler';\nimport DriveSyncHandler, { DriveSignInState } from './DriveSyncHandler';\n\n\ndeclare var gapi: any\n\nconst SYNC_TIMEOUT = 2000;\n\ninterface AppProps {\n}\n\ninterface AppState {\n  focusedNoteRowId: number\n  note: Note\n}\n\ninterface ViewInDocsLinkProps {\n  noteDriveId: string;\n}\n\ninterface ViewInDocsLinkState {\n}\n\nclass ViewInDocsLink extends React.Component<ViewInDocsLinkProps, ViewInDocsLinkState> {\n  render() {\n    return (\n      <div className=\"view-in-docs-link\" >\n        {this.props.noteDriveId.length > 0 && \n            <a href={\"https://docs.google.com/document/d/\" + this.props.noteDriveId + \"/edit\"}\n          target=\"_blank\">\n            View Note in Docs\n          </a>}\n      </div>\n    )\n  }\n}\n\nclass App extends React.Component<AppProps, AppState> {\n  wrapperElement = React.createRef<HTMLDivElement>();\n\n  // Initialize to true so that we do a sync on load.\n  private editedSinceLastDriveSync = false;\n  private syncTimer: NodeJS.Timeout | null = null;\n\n  constructor(props: AppProps) {\n    super(props);\n    DriveSyncHandler.init();\n\n    let note = NoteContentHandler.getLastEditedNote();\n    let firstNoteLineId: number;\n\n    if (note === null) {\n      note = this.createNewNote();\n      firstNoteLineId = note.getFirstNoteLineId();\n    } else {\n      firstNoteLineId = note.getFirstNoteLineId();\n    }\n    this.state = { note: note, focusedNoteRowId: firstNoteLineId };\n  }\n\n  createNewNote(): Note {\n      let note = new Note();\n      note.addLine();\n\n      return note;\n  }\n\n  componentDidMount() {\n    DriveSyncHandler.addSignInStateHandler((state: DriveSignInState) => {\n      if (state !== DriveSignInState.SIGNED_IN) {\n        if (this.syncTimer !== null) {\n          clearTimeout(this.syncTimer);\n          this.syncTimer = null;\n        }\n        return;\n      }\n\n      DriveSyncHandler.saveNote(this.state.note);\n      this.syncTimer = setInterval(async () => {\n        if (this.editedSinceLastDriveSync) {\n          let id = await DriveSyncHandler.saveNote(this.state.note);\n          let note = this.state.note;\n          note.setDriveId(id);\n          this.editedSinceLastDriveSync = false;\n\n          this.setState({ note: note})\n        }\n      }, SYNC_TIMEOUT);\n    });\n  }\n\n  render() {\n    let noteRows = this.state.note.getLines().map(noteRow => {\n      return (<NoteRow keyDownHandler={this.handleNoteRowKeyDown.bind(this)}\n        focusHandler={this.noteRowFocusHandler.bind(this)}\n        note={this.state.note}\n        rowId={noteRow.id}\n        key={noteRow.id}\n        focused={noteRow.id === this.state.focusedNoteRowId} />);\n    });\n\n    return (\n      <div className=\"App\" ref={this.wrapperElement}>\n        <div className=\"header\">\n          <NoteTitle title={this.state.note.getTitle()} titleChangeHandler={this.handleTitleChange.bind(this)} />\n          <ViewInDocsLink noteDriveId={this.state.note.getDriveId()} />\n          <Menu noteFinished={this.state.note.getFinished()} \n            newNoteHandler={this.newNoteHandler.bind(this)}\n            finishToggleHandler={this.handleToggleFinished.bind(this)}\n            signOutHandler={this.signOutHandler.bind(this)}\n            signInHandler={this.signInHandler.bind(this)} />\n        </div>\n        {noteRows}\n      </div>\n    );\n  }\n\n  signInHandler() {\n    gapi.auth2.getAuthInstance().signIn();\n  }\n\n  signOutHandler() {\n    gapi.auth2.getAuthInstance().signOut();\n  }\n\n  handleTitleChange(newTitle: string) {\n    this.state.note.setTitle(newTitle);\n    this.setState({ note: this.state.note });\n    NoteContentHandler.updateNote(this.state.note);\n  }\n\n  handleToggleFinished() {\n    let note = this.state.note;\n\n    note.setFinished(!note.getFinished());\n    this.setState({ note: note });\n  }\n\n  newNoteHandler() {\n    let note = this.createNewNote();\n    this.setState({ note: note, focusedNoteRowId: note.getFirstNoteLineId() });\n  }\n\n  handleNoteRowKeyDown(noteRow: NoteLine, e: React.KeyboardEvent) {\n    this.editedSinceLastDriveSync = true;\n\n    if (e.key === \"Enter\") {\n      e.preventDefault();\n      this.setState((props, state) => {\n        let note = this.state.note;\n        let newNote = note.addLine(noteRow.getIndentedUnits());\n\n        return { note: note, focusedNoteRowId: newNote.id }\n      });\n      return false;\n    } else if (e.key === \"Backspace\") {\n      let focusedRow = this.state.note.getLine(this.state.focusedNoteRowId);\n      if (focusedRow !== undefined && focusedRow.isEmpty() && this.state.note.getLines().length > 1) {\n        let nextFocusedRowId = this.state.note.getPreviousRowId(this.state.focusedNoteRowId);\n        this.state.note.deleteRow(this.state.focusedNoteRowId);\n\n        if (nextFocusedRowId !== null) {\n          this.setState({ focusedNoteRowId: nextFocusedRowId });\n        } else {\n          console.error(\"Got a null previous row id relative to: \", this.state.focusedNoteRowId);\n          this.setState({ focusedNoteRowId: this.state.note.getFirstNoteLineId() });\n        }\n\n        NoteContentHandler.updateNote(this.state.note);\n\n        // Since we're catching the keydown event, if we don't call preventDefault,\n        // a character will get deleted on the line that gets focus.\n        e.preventDefault();\n\n      }\n    } else {\n      return true;\n    }\n\n  }\n\n  noteRowFocusHandler(note: NoteLine) {\n    this.setState({ focusedNoteRowId: note.id });\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}